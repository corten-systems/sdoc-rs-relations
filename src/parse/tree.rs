use crate::parse::Span;

use paste::paste;
use serde::Serialize;
use syn::spanned::Spanned;
use syn::visit::{self, Visit};
use syn::{Attribute, File, Meta, MetaNameValue};

/// Where do these come from?
///
/// They are all the visitable nodes in the `syn` crate that have `Attribute`s.
///
/// They are all generated by running the following script on the `syn` crate.
///
/// https://github.com/dtolnay/syn.git // See `Cargo.toml` for the version tag
///
/// ```bash
/// //
/// // for rs in *.rs ; do
/// //     awk '!/^\/\/!/ { if (/pub attrs: Vec<Attribute>/) print prev; if (/ struct /) prev = $0 }' "${rs}"
/// // done | sort | awk '{ printf "visit!(%s);\n", $3 }'
/// //
/// ```
///
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize)]
pub enum Scope {
    Arm,
    BareFnArg,
    BareVariadic,
    ConstParam,
    DeriveInput,
    ExprArray,
    ExprAssign,
    ExprAsync,
    ExprAwait,
    ExprBinary,
    ExprBlock,
    ExprBreak,
    ExprCall,
    ExprCast,
    ExprClosure,
    ExprConst,
    ExprContinue,
    ExprField,
    ExprForLoop,
    ExprGroup,
    ExprIf,
    ExprIndex,
    ExprInfer,
    ExprLet,
    ExprLit,
    ExprLoop,
    ExprMacro,
    ExprMatch,
    ExprMethodCall,
    ExprParen,
    ExprPath,
    ExprRange,
    ExprRawAddr,
    ExprReference,
    ExprRepeat,
    ExprReturn,
    ExprStruct,
    ExprTry,
    ExprTryBlock,
    ExprTuple,
    ExprUnary,
    ExprUnsafe,
    ExprWhile,
    ExprYield,
    Field,
    FieldPat,
    FieldValue,
    File,
    ForeignItemFn,
    ForeignItemMacro,
    ForeignItemStatic,
    ForeignItemType,
    ImplItemConst,
    ImplItemFn,
    ImplItemMacro,
    ImplItemType,
    ItemConst,
    ItemEnum,
    ItemExternCrate,
    ItemFn,
    ItemForeignMod,
    ItemImpl,
    ItemMacro,
    ItemMod,
    ItemStatic,
    ItemStruct,
    ItemTrait,
    ItemTraitAlias,
    ItemType,
    ItemUnion,
    ItemUse,
    LifetimeParam,
    Local,
    PatIdent,
    PatOr,
    PatParen,
    PatReference,
    PatRest,
    PatSlice,
    PatStruct,
    PatTuple,
    PatTupleStruct,
    PatType,
    PatWild,
    Receiver,
    StmtMacro,
    TraitItemConst,
    TraitItemFn,
    TraitItemMacro,
    TraitItemType,
    TypeParam,
    Variadic,
    Variant,
}

#[derive(Clone, Debug)]
pub struct Place {
    pub scope: Scope,
    pub span: Span,
    pub docs: Vec<String>,
}

#[derive(Clone, Default, Debug)]
pub struct Visitor {
    pub places: Vec<Place>,
}

impl Visitor {
    pub fn visit(file: &File) -> Vec<Place> {
        let mut visitor = Visitor::default();
        visitor.visit_file(file);
        visitor.places
    }

    pub fn process(&mut self, scope: Scope, span: Span, attributes: &[Attribute]) {
        let mut place = Place {
            scope,
            span,
            docs: vec![],
        };
     // println!("\n{:?}", &place);
        for attribute in attributes {
            if let Meta::NameValue(MetaNameValue {
                value:
                    syn::Expr::Lit(syn::ExprLit {
                        lit: syn::Lit::Str(literal_string),
                        ..
                    }),
                ..
            }) = &attribute.meta
                && attribute.path().is_ident("doc")
            {
                place.docs.push(literal_string.value());
            }
        }
        self.places.push(place);
    }
}

macro_rules! visit {
    ($ident:ident) => {
        paste! {
            fn [<visit_ $ident:snake>](&mut self, node: &'ast syn::$ident) {
                self.process(Scope::$ident, node.span().into(), &node.attrs);
                visit::[<visit_ $ident:snake>](self, node);
            }
        }
    };
}

/// To see the raw AST, use `rustc +nightly --edition 2024 -Z unpretty=ast-tree file.rs`
///
impl<'ast> Visit<'ast> for Visitor {
    //
    // These should be one-to-one with the `Scope` enum.
    //
    visit!(Arm);
    visit!(BareFnArg);
    visit!(BareVariadic);
    visit!(ConstParam);
    visit!(DeriveInput);
    visit!(ExprArray);
    visit!(ExprAssign);
    visit!(ExprAsync);
    visit!(ExprAwait);
    visit!(ExprBinary);
    visit!(ExprBlock);
    visit!(ExprBreak);
    visit!(ExprCall);
    visit!(ExprCast);
    visit!(ExprClosure);
    visit!(ExprConst);
    visit!(ExprContinue);
    visit!(ExprField);
    visit!(ExprForLoop);
    visit!(ExprGroup);
    visit!(ExprIf);
    visit!(ExprIndex);
    visit!(ExprInfer);
    visit!(ExprLet);
    visit!(ExprLit);
    visit!(ExprLoop);
    visit!(ExprMacro);
    visit!(ExprMatch);
    visit!(ExprMethodCall);
    visit!(ExprParen);
    visit!(ExprPath);
    visit!(ExprRange);
    visit!(ExprRawAddr);
    visit!(ExprReference);
    visit!(ExprRepeat);
    visit!(ExprReturn);
    visit!(ExprStruct);
    visit!(ExprTry);
    visit!(ExprTryBlock);
    visit!(ExprTuple);
    visit!(ExprUnary);
    visit!(ExprUnsafe);
    visit!(ExprWhile);
    visit!(ExprYield);
    visit!(Field);
    visit!(FieldPat);
    visit!(FieldValue);
    visit!(File);
    visit!(ForeignItemFn);
    visit!(ForeignItemMacro);
    visit!(ForeignItemStatic);
    visit!(ForeignItemType);
    visit!(ImplItemConst);
    visit!(ImplItemFn);
    visit!(ImplItemMacro);
    visit!(ImplItemType);
    visit!(ItemConst);
    visit!(ItemEnum);
    visit!(ItemExternCrate);
    visit!(ItemFn);
    visit!(ItemForeignMod);
    visit!(ItemImpl);
    visit!(ItemMacro);
    visit!(ItemMod);
    visit!(ItemStatic);
    visit!(ItemStruct);
    visit!(ItemTrait);
    visit!(ItemTraitAlias);
    visit!(ItemType);
    visit!(ItemUnion);
    visit!(ItemUse);
    visit!(LifetimeParam);
    visit!(Local);
    visit!(PatIdent);
    visit!(PatOr);
    visit!(PatParen);
    visit!(PatReference);
    visit!(PatRest);
    visit!(PatSlice);
    visit!(PatStruct);
    visit!(PatTuple);
    visit!(PatTupleStruct);
    visit!(PatType);
    visit!(PatWild);
    visit!(Receiver);
    visit!(StmtMacro);
    visit!(TraitItemConst);
    visit!(TraitItemFn);
    visit!(TraitItemMacro);
    visit!(TraitItemType);
    visit!(TypeParam);
    visit!(Variadic);
    visit!(Variant);
}
